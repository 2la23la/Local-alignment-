#Noha Mohamed Ahmed Abdelbary
#Alaa Alaa Abdelhamid Ibrahim
#Ahmed Yasser Hassan
#Youssef Mohamed Sayed
#Ahmed Yasser Aly
#Batoul adel hussien
BlosumMat = {
    ('W', 'F'): 1, ('L', 'R'): -2, ('S', 'P'): -1, ('V', 'T'): 0,
    ('Q', 'Q'): 5, ('N', 'A'): -2, ('Z', 'Y'): -2, ('W', 'R'): -3,
    ('Q', 'A'): -1, ('S', 'D'): 0, ('H', 'H'): 8, ('S', 'H'): -1,
    ('H', 'D'): -1, ('L', 'N'): -3, ('W', 'A'): -3, ('Y', 'M'): -1,
    ('G', 'R'): -2, ('Y', 'I'): -1, ('Y', 'E'): -2, ('B', 'Y'): -3,
    ('Y', 'A'): -2, ('V', 'D'): -3, ('B', 'S'): 0, ('Y', 'Y'): 7,
    ('G', 'N'): 0, ('E', 'C'): -4, ('Y', 'Q'): -1, ('Z', 'Z'): 4,
    ('V', 'A'): 0, ('C', 'C'): 9, ('M', 'R'): -1, ('V', 'E'): -2,
    ('T', 'N'): 0, ('P', 'P'): 7, ('V', 'I'): 3, ('V', 'S'): -2,
    ('Z', 'P'): -1, ('V', 'M'): 1, ('T', 'F'): -2, ('V', 'Q'): -2,
    ('K', 'K'): 5, ('P', 'D'): -1, ('I', 'H'): -3, ('I', 'D'): -3,
    ('T', 'R'): -1, ('P', 'L'): -3, ('K', 'G'): -2, ('M', 'N'): -2,
    ('P', 'H'): -2, ('F', 'Q'): -3, ('Z', 'G'): -2, ('X', 'L'): -1,
    ('T', 'M'): -1, ('Z', 'C'): -3, ('X', 'H'): -1, ('D', 'R'): -2,
    ('B', 'W'): -4, ('X', 'D'): -1, ('Z', 'K'): 1, ('F', 'A'): -2,
    ('Z', 'W'): -3, ('F', 'E'): -3, ('D', 'N'): 1, ('B', 'K'): 0,
    ('X', 'X'): -1, ('F', 'I'): 0, ('B', 'G'): -1, ('X', 'T'): 0,
    ('F', 'M'): 0, ('B', 'C'): -3, ('Z', 'I'): -3, ('Z', 'V'): -2,
    ('S', 'S'): 4, ('L', 'Q'): -2, ('W', 'E'): -3, ('Q', 'R'): 1,
    ('N', 'N'): 6, ('W', 'M'): -1, ('Q', 'C'): -3, ('W', 'I'): -3,
    ('S', 'C'): -1, ('L', 'A'): -1, ('S', 'G'): 0, ('L', 'E'): -3,
    ('W', 'Q'): -2, ('H', 'G'): -2, ('S', 'K'): 0, ('Q', 'N'): 0,
    ('N', 'R'): 0, ('H', 'C'): -3, ('Y', 'N'): -2, ('G', 'Q'): -2,
    ('Y', 'F'): 3, ('C', 'A'): 0, ('V', 'L'): 1, ('G', 'E'): -2,
    ('G', 'A'): 0, ('K', 'R'): 2, ('E', 'D'): 2, ('Y', 'R'): -2,
    ('M', 'Q'): 0, ('T', 'I'): -1, ('C', 'D'): -3, ('V', 'F'): -1,
    ('T', 'A'): 0, ('T', 'P'): -1, ('B', 'P'): -2, ('T', 'E'): -1,
    ('V', 'N'): -3, ('P', 'G'): -2, ('M', 'A'): -1, ('K', 'H'): -1,
    ('V', 'R'): -3, ('P', 'C'): -3, ('M', 'E'): -2, ('K', 'L'): -2,
    ('V', 'V'): 4, ('M', 'I'): 1, ('T', 'Q'): -1, ('I', 'G'): -4,
    ('P', 'K'): -1, ('M', 'M'): 5, ('K', 'D'): -1, ('I', 'C'): -1,
    ('Z', 'D'): 1, ('F', 'R'): -3, ('X', 'K'): -1, ('Q', 'D'): 0,
    ('X', 'G'): -1, ('Z', 'L'): -3, ('X', 'C'): -2, ('Z', 'H'): 0,
    ('B', 'L'): -4, ('B', 'H'): 0, ('F', 'F'): 6, ('X', 'W'): -2,
    ('B', 'D'): 4, ('D', 'A'): -2, ('S', 'L'): -2, ('X', 'S'): 0,
    ('F', 'N'): -3, ('S', 'R'): -1, ('W', 'D'): -4, ('V', 'Y'): -1,
    ('W', 'L'): -2, ('H', 'R'): 0, ('W', 'H'): -2, ('H', 'N'): 1,
    ('W', 'T'): -2, ('T', 'T'): 5, ('S', 'F'): -2, ('W', 'P'): -4,
    ('L', 'D'): -4, ('B', 'I'): -3, ('L', 'H'): -3, ('S', 'N'): 1,
    ('B', 'T'): -1, ('L', 'L'): 4, ('Y', 'K'): -2, ('E', 'Q'): 2,
    ('Y', 'G'): -3, ('Z', 'S'): 0, ('Y', 'C'): -2, ('G', 'D'): -1,
    ('B', 'V'): -3, ('E', 'A'): -1, ('Y', 'W'): 2, ('E', 'E'): 5,
    ('Y', 'S'): -2, ('C', 'N'): -3, ('V', 'C'): -1, ('T', 'H'): -2,
    ('P', 'R'): -2, ('V', 'G'): -3, ('T', 'L'): -1, ('V', 'K'): -2,
    ('K', 'Q'): 1, ('R', 'A'): -1, ('I', 'R'): -3, ('T', 'D'): -1,
    ('P', 'F'): -4, ('I', 'N'): -3, ('K', 'I'): -3, ('M', 'D'): -3,
    ('V', 'W'): -3, ('W', 'W'): 11, ('M', 'H'): -2, ('P', 'N'): -2,
    ('K', 'A'): -1, ('M', 'L'): 2, ('K', 'E'): 1, ('Z', 'E'): 4,
    ('X', 'N'): -1, ('Z', 'A'): -1, ('Z', 'M'): -1, ('X', 'F'): -1,
    ('K', 'C'): -3, ('B', 'Q'): 0, ('X', 'B'): -1, ('B', 'M'): -3,
    ('F', 'C'): -2, ('Z', 'Q'): 3, ('X', 'Z'): -1, ('F', 'G'): -3,
    ('B', 'E'): 1, ('X', 'V'): -1, ('F', 'K'): -3, ('B', 'A'): -2,
    ('X', 'R'): -1, ('D', 'D'): 6, ('W', 'G'): -2, ('Z', 'F'): -3,
    ('S', 'Q'): 0, ('W', 'C'): -2, ('W', 'K'): -3, ('H', 'Q'): 0,
    ('L', 'C'): -1, ('W', 'N'): -4, ('S', 'A'): 1, ('L', 'G'): -4,
    ('W', 'S'): -3, ('S', 'E'): 0, ('H', 'E'): 0, ('S', 'I'): -2,
    ('H', 'A'): -2, ('S', 'M'): -1, ('Y', 'L'): -1, ('Y', 'H'): 2,
    ('Y', 'D'): -3, ('E', 'R'): 0, ('X', 'P'): -2, ('G', 'G'): 6,
    ('G', 'C'): -3, ('E', 'N'): 0, ('Y', 'T'): -2, ('Y', 'P'): -3,
    ('T', 'K'): -1, ('A', 'A'): 4, ('P', 'Q'): -1, ('T', 'C'): -1,
    ('V', 'H'): -3, ('T', 'G'): -2, ('I', 'Q'): -3, ('Z', 'T'): -1,
    ('C', 'R'): -3, ('V', 'P'): -2, ('P', 'E'): -1, ('M', 'C'): -1,
    ('K', 'N'): 0, ('I', 'I'): 4, ('P', 'A'): -1, ('M', 'G'): -3,
    ('T', 'S'): 1, ('I', 'E'): -3, ('P', 'M'): -2, ('M', 'K'): -1,
    ('I', 'A'): -1, ('P', 'I'): -3, ('R', 'R'): 5, ('X', 'M'): -1,
    ('L', 'I'): 2, ('X', 'I'): -1, ('Z', 'B'): 1, ('X', 'E'): -1,
    ('Z', 'N'): 0, ('X', 'A'): 0, ('B', 'R'): -1, ('B', 'N'): 3,
    ('F', 'D'): -3, ('X', 'Y'): -1, ('Z', 'R'): 0, ('F', 'H'): -1,
    ('B', 'F'): -3, ('F', 'L'): 0, ('X', 'Q'): -1, ('B', 'B'): 4
}


# dna and protein
def valid_seq(validation, seq):
    seq = seq.upper()
    return (all(i in validation for i in seq))


# dna and proten
def initialization(seq1, seq2):
    seq1_len = len(seq1)
    seq2_len = len(seq2)
    global matrix
    matrix = [[0 for x in range(seq1_len + 1)] for y in range(seq2_len + 1)]  # setting zeros to our matrix


def filling_DNA(seq1, seq2, gap):
    max_score = []
    seq1_len = len(seq1)
    seq2_len = len(seq2)
    for i in range(1, seq2_len + 1):
        for j in range(1, seq1_len + 1):
            if seq1[j - 1] == seq2[i - 1]:  # specify the match and mismatch of the diagonal
                score = 1  # match score
            else:
                score = -2  # mismatch score
            # assigning the intersaction cell to the max num the came from the diagonal or top or left
            matrix[i][j] = max(matrix[i - 1][j] + gap, matrix[i][j - 1] + gap, matrix[i - 1][j - 1] + score, 0)
            if len(max_score) == 0 or max_score[2] == matrix[i][j]:  # putting the optimal cells
                max_score.append(i)
                max_score.append(j)
                max_score.append(matrix[i][j])
            else:
                if max_score[2] < matrix[i][j]:
                    max_score *= 0
                    max_score.append(i)
                    max_score.append(j)
                    max_score.append(matrix[i][j])

    return (max_score)


def filling_protein(seq1, seq2, gap):
    max_score = -1
    seq1_len = len(seq1)
    seq2_len = len(seq2)
    for i in range(1, seq2_len + 1, 1):
        for j in range(1, seq1_len + 1, 1):
            k = seq1[j - 1].upper()
            z = seq2[i - 1].upper()
            if BlosumMat.get((k, z)) is None:
                score = BlosumMat.get((z, k))
            else:
                score = BlosumMat.get((k, z))
            # fill the matrix
            matrix[i][j] = max(matrix[i - 1][j] + gap, matrix[i][j - 1] + gap, matrix[i - 1][j - 1] + score, 0)
            if matrix[i][j] > max_score:
                max_score = matrix[i][j]
                row_index = i
                col_index = j

    return (row_index, col_index)


def traceback_DNA(seq1, seq2, max_score, gap):
    TB1 = []
    TB2 = []
    for a in range(0, len(max_score), 3):
        TBseq1 = ' '
        TBseq2 = ' '
        i = max_score[a]
        j = max_score[a + 1]
        while matrix[i][j] != 0:
            left = matrix[i][j - 1] + gap
            up = matrix[i - 1][j] + gap
            if seq1[j - 1] == seq2[i - 1]:
                score = 1
            else:
                score = -2
            diagonal = matrix[i - 1][j - 1] + score

            # traceback start
            if matrix[i][j] == diagonal:
                TBseq1 += seq1[j - 1]
                TBseq2 += seq2[i - 1]
                i -= 1
                j -= 1
            elif matrix[i][j] == up:
                TBseq1 += '-'
                TBseq2 += seq2[i - 1]
                i -= 1
            elif matrix[i][j] == left:
                TBseq2 += '-'
                TBseq1 += seq1[j - 1]
                j -= 1
        TB1.append(TBseq1[::-1])
        TB2.append(TBseq2[::-1])
    print(TB1)
    print(TB2)


def traceback_protein(seq1, seq2, row_index, col_index, gap):
    TBseq1 = " "
    TBseq2 = " "
    while matrix[row_index][col_index] != 0:
        up = matrix[row_index - 1][col_index] + gap
        left = matrix[row_index][col_index - 1] + gap
        K = seq1[col_index - 1].upper()
        Z = seq2[row_index - 1].upper()
        if BlosumMat.get((K, Z)) is None:
            score = BlosumMat.get((Z, K))
        else:
            score = BlosumMat.get((K, Z))

        diagonal = matrix[row_index - 1][col_index - 1] + score
        if matrix[row_index][col_index] == diagonal:
            TBseq1 += seq1[col_index - 1]
            TBseq2 += seq2[row_index - 1]
            row_index -= 1
            col_index -= 1
        elif matrix[row_index][col_index] == up:
            TBseq1 += "-"
            TBseq2 += seq2[row_index - 1]
            row_index -= 1

        elif matrix[row_index][col_index] == left:
            TBseq2 += "-"
            TBseq1 += seq1[col_index - 1]
            col_index -= 1

    print(TBseq1[::-1])
    print(TBseq2[::-1])


def Local_alignment():
    choice = input("press 1 for DNA \n press 2 for protein\n")
    if choice == '1':
        Bases = ['A', 'T', 'C', 'G']
        seq1 = input("Enter the first DNA sequence: ")
        seq2 = input("Enter the second DNA sequence: ")
        if (valid_seq(Bases, seq1)) and (valid_seq(Bases, seq2)):
            initialization(seq1, seq2)
            max = filling_DNA(seq1, seq2, -1)
            traceback_DNA(seq1, seq2, max, -1)
        else:
            print("invalid DNA sequence")

    elif choice == '2':
        aminoAcids = ['W', 'F', 'L', 'R', 'S', 'P', 'V', 'T', 'Q', 'N', 'A', 'Z', 'Y', 'D', 'H', 'M', 'G', 'I', 'E',
                      'B']
        seq1 = input("enter first protein sequence:")
        seq2 = input("enter second protein sequence:")
        if (valid_seq(aminoAcids, seq1)) and (valid_seq(aminoAcids, seq2)):
            initialization(seq1, seq2)
            row_index, col_index = filling_protein(seq1, seq2, -8)
            traceback_protein(seq1, seq2, row_index, col_index, -8)
        else:
            print("invalid protein sequence")

    else:
        print("incorrect choice")


Local_alignment()